<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Price Mismatch Dashboard</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <%- include('partials/header', {
        pageTitle: 'GTIN Master Inventory',
        currentView: 'gtin',
        merchant: null,
        merchantId: null,
        merchants: typeof merchants !== 'undefined' ? merchants : [],
        activePage: 'dashboard-gtin',
      }) %>

  <p class="hint">
    Rows highlighted have different prices across locations.
  </p>

  <table id="inventory-table">
    <thead>
      <tr id="header-row">
        <th class="sortable" data-key="gtin" data-type="string">GTIN</th>
        <th class="sortable" data-key="item_name" data-type="string">Item</th>
        <th class="sortable" data-key="category_name" data-type="string">Category</th>
        <th class="sortable" data-key="sku" data-type="string">SKU</th>
        <!-- Location price columns injected by JS -->
      </tr>
    </thead>
    <tbody id="inventory-body"></tbody>
  </table>

  <div class="pagination">
    <span id="page-info"></span>
    <span>
      Rows per page:
      <select id="rowsPerPage">
        <option value="25">25</option>
        <option value="50" selected>50</option>
        <option value="100">100</option>
        <option value="250">250</option>
      </select>
    </span>
    <button id="prevPage">&laquo; Prev</button>
    <button id="nextPage">Next &raquo;</button>
  </div>

  <%- include('partials/footer') %>

  <script>

    // header view switch
    const viewSelect = document.getElementById('viewSelect');
    if (viewSelect) viewSelect.addEventListener('change', () => {
      const val = viewSelect.value;
      if (val) window.location.href = val;
    });

    // loader (from header.ejs)
    const topLoader = document.getElementById('top-loader');
    const topLoaderBar = document.getElementById('top-loader-bar');
    const miniSpinner = document.getElementById('mini-spinner');

    let loaderTimer = null;
    function startLoading() {
      if (topLoader) topLoader.classList.add('is-on');
      if (miniSpinner) miniSpinner.classList.add('is-on');
      if (topLoaderBar) topLoaderBar.style.width = '10%';

      let p = 10;
      clearInterval(loaderTimer);
      loaderTimer = setInterval(() => {
        p = Math.min(p + Math.random() * 12, 92);
        if (topLoaderBar) topLoaderBar.style.width = p.toFixed(0) + '%';
      }, 180);
    }

    function stopLoading() {
      clearInterval(loaderTimer);
      loaderTimer = null;

      if (topLoaderBar) topLoaderBar.style.width = '100%';
      setTimeout(() => {
        if (topLoader) topLoader.classList.remove('is-on');
        if (miniSpinner) miniSpinner.classList.remove('is-on');
        if (topLoaderBar) topLoaderBar.style.width = '0%';
      }, 180);
    }

    // table/paging
    const headerRow = document.getElementById('header-row');
    const tbody = document.getElementById('inventory-body');
    const pageInfo = document.getElementById('page-info');
    const rowsPerPageSelect = document.getElementById('rowsPerPage');
    const prevBtn = document.getElementById('prevPage');
    const nextBtn = document.getElementById('nextPage');
    const searchInput = document.getElementById('search');

    let locationKeys = [];
    let headerBuilt = false;

    let pages = [];        // [{ rows, nextCursor }]
    let cursors = [null];  // cursor for each page
    let currentPageIndex = 0;
    let rowsPerPage = Number(rowsPerPageSelect.value) || 50;

    let currentRows = [];
    let currentSort = { key: null, direction: 'asc', type: 'string' };

    let inflight = null;

    // ðŸ”¹ Single query string; backend will normalize "200 ml" -> "200ml"
    let currentQueryRaw = '';

    function renderSkeleton() {
      tbody.innerHTML = '';
      for (let i = 0; i < 10; i++) {
        const tr = document.createElement('tr');
        tr.innerHTML =
          `<td colspan="${4 + (locationKeys?.length || 0)}" ` +
          `style="padding:14px;opacity:.35;">&nbsp;</td>`;
        tbody.appendChild(tr);
      }
    }

    function ensureHeader(locKeys) {
      if (headerBuilt) return;
      locationKeys = Array.isArray(locKeys) ? locKeys : [];
      locationKeys.forEach(locKey => {
        const th = document.createElement('th');
        th.textContent = locKey + ' (Price)';
        headerRow.appendChild(th);
      });
      headerBuilt = true;
    }

    function getHeaderCells() {
      return Array.from(
        document.querySelectorAll('#inventory-table thead th.sortable')
      );
    }

    function clearSortIndicators() {
      getHeaderCells().forEach(th =>
        th.classList.remove('sorted-asc', 'sorted-desc')
      );
    }

    function sortBy(key, type) {
      if (!key) return;
      if (currentSort.key === key) {
        currentSort.direction =
          currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.key = key;
        currentSort.direction = 'asc';
      }
      currentSort.type = type || 'string';

      clearSortIndicators();
      getHeaderCells().forEach(th => {
        if (th.dataset.key === key) {
          th.classList.add(
            currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc'
          );
        }
      });

      renderTable();
    }

    async function fetchPage(pageIndexToLoad) {
      const cursor = cursors[pageIndexToLoad] || null;
    
      const params = new URLSearchParams();
      params.set('pageSize', String(rowsPerPage));
      if (cursor) params.set('cursor', cursor);

      // ðŸ”¹ Send raw search; backend will lowercase + strip spaces
      if (currentQueryRaw) params.set('q', currentQueryRaw);

      const url = '/api/gtin-matrix?' + params.toString();

      if (inflight) inflight.abort();
      inflight = new AbortController();

      startLoading();

      const res = await fetch(url, {
        headers: { 'Accept': 'application/json' },
        signal: inflight.signal,
      });
      if (!res.ok) throw new Error(await res.text());

      const data = await res.json();

      if (!headerBuilt && data.locations) ensureHeader(data.locations);

      const rows = (data.rows || []).map(r => ({
        gtin: r.gtin || '',
        item_name: r.item_name || '',
        category_name: r.category_name || '',
        sku: r.sku || '',
        pricesByLocation: r.pricesByLocation || {},
      }));

      pages[pageIndexToLoad] = {
        rows,
        nextCursor: data.nextCursor || null,
      };
      cursors[pageIndexToLoad + 1] = data.nextCursor || null;

      stopLoading();
      return rows;
    }

    async function loadPage(pageIndex) {
      currentPageIndex = pageIndex;

      if (!pages[pageIndex]) {
        renderSkeleton();
        await fetchPage(pageIndex);
      }

      currentRows = (pages[pageIndex]?.rows || []).slice();
      renderTable();
    }

    function isMismatchRow(r) {
      const prices = [];
      for (const locKey of locationKeys) {
        const info = r.pricesByLocation?.[locKey];
        if (info && typeof info.price === 'number') prices.push(info.price);
      }
      if (prices.length <= 1) return false;
      const first = prices[0];
      return prices.some(p => Math.abs(p - first) > 0.0001);
    }

    function renderTable() {
      tbody.innerHTML = '';

      if (currentSort.key) {
        const { key, type, direction } = currentSort;
        const dir = direction === 'asc' ? 1 : -1;

        currentRows.sort((a, b) => {
          const va = a[key];
          const vb = b[key];

          if (type === 'number') {
            const na =
              va == null || isNaN(va) ? -Infinity : Number(va);
            const nb =
              vb == null || isNaN(vb) ? -Infinity : Number(vb);
            if (na < nb) return -1 * dir;
            if (na > nb) return 1 * dir;
            return 0;
          } else {
            const sa = (va ?? '').toString().toLowerCase();
            const sb = (vb ?? '').toString().toLowerCase();
            if (sa < sb) return -1 * dir;
            if (sa > sb) return 1 * dir;
            return 0;
          }
        });
      }

      if (!currentRows.length) {
        tbody.innerHTML =
          `<tr><td colspan="${4 + locationKeys.length}">No GTIN rows found.</td></tr>`;
        pageInfo.textContent = `Page ${currentPageIndex + 1} (0 rows)`;
        prevBtn.disabled = currentPageIndex <= 0;
        nextBtn.disabled = !(
          pages[currentPageIndex] &&
          pages[currentPageIndex].nextCursor
        );
        return;
      }

      for (const r of currentRows) {
        const tr = document.createElement('tr');
        if (isMismatchRow(r)) tr.classList.add('mismatch-row');

        // GTIN
        const tdGtin = document.createElement('td');
        tdGtin.textContent = r.gtin;
        tr.appendChild(tdGtin);

        // Name editable
        const tdName = document.createElement('td');
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'name-input';
        nameInput.value = r.item_name || '';
        nameInput.dataset.gtin = r.gtin || '';
        nameInput.addEventListener('change', handleNameChange);
        tdName.appendChild(nameInput);
        tr.appendChild(tdName);

        // Category
        const tdCat = document.createElement('td');
        tdCat.textContent = r.category_name || '';
        tr.appendChild(tdCat);

        // SKU
        const tdSku = document.createElement('td');
        tdSku.textContent = r.sku || '';
        tr.appendChild(tdSku);

        // Price cells
        locationKeys.forEach(locKey => {
          const td = document.createElement('td');
          const info = r.pricesByLocation?.[locKey];

          if (info) {
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '0.01';
            input.className = 'price-input';
            if (info.price != null)
              input.value = Number(info.price).toFixed(2);

            input.dataset.merchantId = info.merchant_id || '';
            input.dataset.variationId = info.variation_id || '';
            input.dataset.currency = info.currency || 'USD';

            input.addEventListener('change', handlePriceChange);
            td.appendChild(input);
          } else {
            td.textContent = '';
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      }

      const hasNext =
        pages[currentPageIndex] &&
        pages[currentPageIndex].nextCursor;
      pageInfo.textContent = `Page ${currentPageIndex + 1} (rows: ${currentRows.length})`;
      prevBtn.disabled = currentPageIndex <= 0;
      nextBtn.disabled = !hasNext;
    }

    // sorting events
    getHeaderCells().forEach(th => {
      th.addEventListener('click', () =>
        sortBy(th.dataset.key, th.dataset.type || 'string')
      );
    });

    // --- DB-backed search (debounced, backend handles space normalization) ---
    let searchDebounce = null;
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        clearTimeout(searchDebounce);
        searchDebounce = setTimeout(() => {
          const raw = (searchInput.value || '').trim().toLowerCase();
          currentQueryRaw = raw; // e.g. "200 ml"

          pages = [];
          cursors = [null];
          currentPageIndex = 0;
          loadPage(0);
        }, 250);
      });
    }

    // paging
    rowsPerPageSelect.addEventListener('change', () => {
      rowsPerPage = Number(rowsPerPageSelect.value) || 50;
      pages = [];
      cursors = [null];
      currentPageIndex = 0;
      loadPage(0);
    });

    prevBtn.addEventListener('click', () => {
      if (currentPageIndex > 0) loadPage(currentPageIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
      const page = pages[currentPageIndex];
      if (page && page.nextCursor) loadPage(currentPageIndex + 1);
    });

    // --- price update ---
    async function handlePriceChange(event) {
      const input = event.target;
      const newValue = input.value.trim();

      const merchantId = input.dataset.merchantId;
      const variationId = input.dataset.variationId;
      const currency = input.dataset.currency || 'USD';

      if (!merchantId || !variationId)
        return alert('Missing merchant/variation info.');

      const numericPrice = Number(newValue);
      if (!newValue || Number.isNaN(numericPrice) || numericPrice < 0) {
        input.classList.add('price-error');
        return alert('Enter a valid non-negative price.');
      }

      input.disabled = true;
      input.classList.remove('price-error');

      try {
        const res = await fetch('/api/update-price', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            merchantId,
            variationId,
            price: numericPrice,
            currency,
          }),
        });
        const data = await res.json();
        if (!res.ok || !data.success)
          throw new Error(data.error || 'Failed to update price');

        input.classList.add('price-updated');
        setTimeout(
          () => input.classList.remove('price-updated'),
          800
        );
      } catch (err) {
        console.error(err);
        input.classList.add('price-error');
        alert('Failed to update price: ' + err.message);
      } finally {
        input.disabled = false;
      }
    }

    // --- name update ---
    async function handleNameChange(event) {
      const input = event.target;
      const newName = input.value.trim();
      const gtin = input.dataset.gtin;

      if (!gtin) return alert('Missing GTIN.');
      if (!newName) {
        input.classList.add('name-error');
        return alert('Item name cannot be empty.');
      }

      input.disabled = true;
      input.classList.remove('name-error');

      try {
        const res = await fetch('/api/update-item-name', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ gtin, itemName: newName }),
        });
        const data = await res.json();
        if (!res.ok || !data.success)
          throw new Error(data.error || 'Failed to update item name');

        input.classList.add('name-updated');
        setTimeout(
          () => input.classList.remove('name-updated'),
          800
        );
      } catch (err) {
        console.error(err);
        input.classList.add('name-error');
        alert('Failed to update item name: ' + err.message);
      } finally {
        input.disabled = false;
      }
    }

    // initial load
    (async () => {
      try {
        await loadPage(0);
      } catch (e) {
        console.error(e);
        stopLoading();
        tbody.innerHTML =
          `<tr><td colspan="4">Failed to load. Check server logs.</td></tr>`;
      }
    })();
  </script>
</body>
</html>
