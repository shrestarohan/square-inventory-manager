<!-- views/dashboard-gtin.ejs
     Price mismatch dashboard (global consolidated view, no merchant dropdown).
     Uses:
       GET /api/gtin-inventory-matrix  -> { rows, locations, nextCursor }
     Server-side filters:
       mismatchOnly=1
       missingOnly=1&missingTarget=<locKey>&missingRequirePresentIn=<locKey>
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Price Mismatch Dashboard</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <%- include('partials/header', {
        pageTitle: 'GTIN Master Inventory',
        currentView: 'gtin',
        merchant: null,
        merchantId: null,
        merchants: typeof merchants !== 'undefined' ? merchants : [],
        activePage: 'dashboard-gtin',
      }) %>

  <p class="hint">
    Rows highlighted have different prices across locations.
  </p>

  <!-- ✅ Server-side filter UI: mismatch + missing filters live in header.ejs -->
  <!-- Required IDs in header.ejs:
       - select#mismatchFilter  (values: "all" | "mismatch")
  -->

  <table id="inventory-table">
    <thead>
      <tr id="header-row">
        <th>Delete</th>
        <th class="sortable" data-key="gtin" data-type="string">GTIN</th>
        <th class="sortable" data-key="sku" data-type="string">SKU</th>
        <th class="sortable" data-key="category_name" data-type="string">Category</th>
        <th class="sortable" data-key="item_name" data-type="string">Item</th>
        <!-- Location price columns injected by JS -->
      </tr>
    </thead>
    <tbody id="inventory-body"></tbody>
  </table>

  <div class="pagination">
    <span id="page-info"></span>
    <span>
      Rows per page:
      <select id="rowsPerPage">
        <option value="25">25</option>
        <option value="50" selected>50</option>
        <option value="100">100</option>
        <option value="250">250</option>
      </select>
    </span>
    <button id="prevPage">&laquo; Prev</button>
    <button id="nextPage">Next &raquo;</button>
  </div>

  <%- include('partials/footer') %>

  <script>
    // ---------- header controls ----------
    const merchantSelect = document.getElementById('merchantSelect');
    if (merchantSelect) merchantSelect.addEventListener('change', () => {
      const val = "/dashboard-gtin/" + merchantSelect.value;
      if (val) window.location.href = val;
    });

    // header view switch
    const viewSelect = document.getElementById('viewSelect');
    if (viewSelect) viewSelect.addEventListener('change', () => {
      const val = viewSelect.value;
      if (val) window.location.href = val;
    });

    // loader (from header.ejs)
    const topLoader = document.getElementById('top-loader');
    const topLoaderBar = document.getElementById('top-loader-bar');
    const miniSpinner = document.getElementById('mini-spinner');

    let loaderTimer = null;
    function startLoading() {
      if (topLoader) topLoader.classList.add('is-on');
      if (miniSpinner) miniSpinner.classList.add('is-on');
      if (topLoaderBar) topLoaderBar.style.width = '10%';

      let p = 10;
      clearInterval(loaderTimer);
      loaderTimer = setInterval(() => {
        p = Math.min(p + Math.random() * 12, 92);
        if (topLoaderBar) topLoaderBar.style.width = p.toFixed(0) + '%';
      }, 180);
    }

    function stopLoading() {
      clearInterval(loaderTimer);
      loaderTimer = null;

      if (topLoaderBar) topLoaderBar.style.width = '100%';
      setTimeout(() => {
        if (topLoader) topLoader.classList.remove('is-on');
        if (miniSpinner) miniSpinner.classList.remove('is-on');
        if (topLoaderBar) topLoaderBar.style.width = '0%';
      }, 180);
    }

    // table/paging
    const headerRow = document.getElementById('header-row');
    const tbody = document.getElementById('inventory-body');
    const pageInfo = document.getElementById('page-info');
    const rowsPerPageSelect = document.getElementById('rowsPerPage');
    const prevBtn = document.getElementById('prevPage');
    const nextBtn = document.getElementById('nextPage');
    const searchInput = document.getElementById('search'); // from header partial, optional

    // ✅ server-side mismatch filter (header.ejs)
    const mismatchFilterSelect = document.getElementById('mismatchFilter');
    let mismatchOnly = false;

    // ✅ server-side missing filter (header.ejs)
    const missingFilterSelect = document.getElementById('missingFilter');          // all | missing
    const missingTargetSelect = document.getElementById('missingTarget');          // locKey
    const missingBaseSelect   = document.getElementById('missingRequireBase');     // optional locKey

    let missingOnly = false;
    let missingTarget = '';
    let missingRequireBase = '';

    let locationKeys = [];
    let locationsMeta = {}; // locKey -> { label, merchant_id, ... }
    let headerBuilt = false;

    function locLabel(locKey) {
      return (locationsMeta && locationsMeta[locKey] && locationsMeta[locKey].label)
        ? locationsMeta[locKey].label
        : locKey;
    }


    let pages = [];        // [{ rows, nextCursor }]
    let cursors = [null];  // cursor for each page
    let currentPageIndex = 0;
    let rowsPerPage = Number(rowsPerPageSelect.value) || 50;

    let currentRows = [];
    let currentSort = { key: null, direction: 'asc', type: 'string' };
    let inflight = null;

    // backend normalizes "200 ml" -> "200ml"
    let currentQueryRaw = '';

    function resetPagingAndLoad() {
      pages = [];
      cursors = [null];
      currentPageIndex = 0;
      loadPage(0);
    }

    // ✅ Bind mismatch filter AFTER paging vars/functions exist
    if (mismatchFilterSelect) {
      mismatchFilterSelect.addEventListener('change', () => {
        mismatchOnly = mismatchFilterSelect.value === 'mismatch';
        resetPagingAndLoad();
      });
    }

    // ✅ Bind missing filters (added in header.ejs)
    if (missingFilterSelect) {
      missingFilterSelect.addEventListener('change', () => {
        missingOnly = missingFilterSelect.value === 'missing';
        resetPagingAndLoad();
      });
    }
    if (missingTargetSelect) {
      missingTargetSelect.addEventListener('change', () => {
        missingTarget = (missingTargetSelect.value || '').trim();
        if (missingOnly) resetPagingAndLoad();
      });
    }
    if (missingBaseSelect) {
      missingBaseSelect.addEventListener('change', () => {
        missingRequireBase = (missingBaseSelect.value || '').trim();
        if (missingOnly) resetPagingAndLoad();
      });
    }

    function renderSkeleton() {
      tbody.innerHTML = '';
      for (let i = 0; i < 10; i++) {
        const tr = document.createElement('tr');
        tr.innerHTML =
          `<td colspan="${5 + (locationKeys?.length || 0)}" ` +
          `style="padding:14px;opacity:.35;">&nbsp;</td>`;
        tbody.appendChild(tr);
      }
    }

    function ensureHeader(locKeys) {
      if (headerBuilt) return;
      locationKeys = Array.isArray(locKeys) ? locKeys : [];
      locationKeys.forEach(locKey => {
        const th = document.createElement('th');
        th.textContent = locLabel(locKey) + ' (Price)';
        headerRow.appendChild(th);
      });
      headerBuilt = true;
    }

    function ensureMissingTargets(locKeys) {
      const keys = Array.isArray(locKeys) ? locKeys : [];

      if (missingTargetSelect && missingTargetSelect.dataset.built !== '1') {
        keys.forEach(k => {
          const opt = document.createElement('option');
          opt.value = k;                 // ✅ keep locKey as value
          opt.textContent = locLabel(k); // ✅ show business name
          missingTargetSelect.appendChild(opt);
        });
        missingTargetSelect.dataset.built = '1';
      }

      if (missingBaseSelect && missingBaseSelect.dataset.built !== '1') {
        keys.forEach(k => {
          const opt = document.createElement('option');
          opt.value = k;
          opt.textContent = locLabel(k);
          missingBaseSelect.appendChild(opt);
        });
        missingBaseSelect.dataset.built = '1';
      }
    }


    function getHeaderCells() {
      return Array.from(document.querySelectorAll('#inventory-table thead th.sortable'));
    }

    function clearSortIndicators() {
      getHeaderCells().forEach(th => th.classList.remove('sorted-asc', 'sorted-desc'));
    }

    function sortBy(key, type) {
      if (!key) return;
      if (currentSort.key === key) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.key = key;
        currentSort.direction = 'asc';
      }
      currentSort.type = type || 'string';

      clearSortIndicators();
      getHeaderCells().forEach(th => {
        if (th.dataset.key === key) {
          th.classList.add(currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
      });

      renderTable();
    }

    async function fetchPage(pageIndexToLoad) {
      const cursor = cursors[pageIndexToLoad] || null;

      const params = new URLSearchParams();
      params.set('pageSize', String(rowsPerPage));
      if (cursor) params.set('cursor', cursor);
      if (currentQueryRaw) params.set('q', currentQueryRaw);

      // ✅ server-side mismatch filter param
      if (mismatchOnly) params.set('mismatchOnly', '1');

      // ✅ server-side missing filter params
      if (missingOnly) {
        params.set('missingOnly', '1');
        if (missingTarget) params.set('missingTarget', missingTarget);
        if (missingRequireBase) params.set('missingRequirePresentIn', missingRequireBase);
      }

      const url = '/api/gtin-inventory-matrix?' + params.toString();

      if (inflight) inflight.abort();
      inflight = new AbortController();

      startLoading();

      const res = await fetch(url, {
        headers: { 'Accept': 'application/json' },
        signal: inflight.signal,
      });

      if (!res.ok) throw new Error(await res.text());
      const data = await res.json();
      
      if (data.locationsMeta) locationsMeta = data.locationsMeta || {};
      if (!headerBuilt && data.locations) ensureHeader(data.locations);
      if (data.locations) ensureMissingTargets(data.locations);

      const rows = (data.rows || []).map(r => ({
        gtin: r.gtin || '',
        item_name: r.item_name || '',
        category_name: r.category_name || '',
        sku: r.sku || '',
        pricesByLocation: r.pricesByLocation || {},
      }));

      pages[pageIndexToLoad] = { rows, nextCursor: data.nextCursor || null };
      cursors[pageIndexToLoad + 1] = data.nextCursor || null;

      stopLoading();
      return rows;
    }

    async function loadPage(pageIndex) {
      currentPageIndex = pageIndex;

      if (!pages[pageIndex]) {
        renderSkeleton();
        await fetchPage(pageIndex);
      }

      currentRows = (pages[pageIndex]?.rows || []).slice();
      renderTable();
    }

    async function handleDeleteGtin(event) {
      const btn = event.target;
      const gtin = (btn.dataset.gtin || '').trim();
      const itemName = (btn.dataset.itemName || '').trim();

      if (!gtin) return alert('Missing GTIN.');

      const ok = confirm(
        `Delete this item everywhere?\n\nGTIN: ${gtin}\nItem: ${itemName || '(no name)'}\n\nThis will remove it from Firestore and Square for each merchant where present.`
      );
      if (!ok) return;

      btn.disabled = true;

      try {
        const res = await fetch('/api/delete-item', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ gtin }),
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.success) throw new Error(data.error || 'Delete failed');

        for (const p of pages) {
          if (!p || !p.rows) continue;
          p.rows = p.rows.filter(row => row.gtin !== gtin);
        }
        currentRows = currentRows.filter(row => row.gtin !== gtin);

        renderTable();
      } catch (err) {
        console.error(err);
        alert('Failed to delete: ' + err.message);
      } finally {
        btn.disabled = false;
      }
    }

    // Used only for row highlighting
    function isMismatchRow(r) {
      const prices = [];
      for (const locKey of locationKeys) {
        const info = r.pricesByLocation?.[locKey];
        if (info && typeof info.price === 'number') prices.push(info.price);
      }
      if (prices.length <= 1) return false;
      const first = prices[0];
      return prices.some(p => Math.abs(p - first) > 0.0001);
    }

    // ✅ Copy item info from one store/location to another
    // Shows a "Copy" button only when a location cell is missing.
    async function handleCopyItemInfo(event) {
      const btn = event.target;
      const gtin = (btn.dataset.gtin || '').trim();
      const toLocKey = (btn.dataset.toLocKey || '').trim();
      const fromLocKey = (btn.dataset.fromLocKey || '').trim();

      if (!gtin) return alert('Missing GTIN.');
      if (!toLocKey) return alert('Missing destination store/location.');
      if (!fromLocKey) return alert('No source store/location found to copy from.');

      /*const ok = confirm(
        `Copy item info?\n\nGTIN: ${gtin}\nFrom: ${fromLocKey}\nTo: ${toLocKey}\n\nThis will copy basic metadata into the destination store (and create a placeholder if missing).`
      );
      if (!ok) return;*/

      const td = btn.closest('td');
      btn.disabled = true;
      const oldText = btn.textContent;
      btn.textContent = 'Copying…';

      try {
        const res = await fetch('/api/copy-item-info', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            gtin,
            fromLocKey,
            toLocKey,
            fields: ['item_name', 'category_name', 'sku'],
            createIfMissing: true,
          }),
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.success) throw new Error(data.error || 'Copy failed');

        // ✅ add this block RIGHT HERE
        const mid = (data.toMerchantId || '').trim();
        const vid = (data.toVariationId || '').trim();

        if (!mid || !vid) {
          // backend didn't return ids yet => keep cell informative, don't show disabled red input
          if (td) {
            td.innerHTML = `<div style="font-size:12px;opacity:.85;">Created. Waiting for IDs…</div>`;
          }
          btn.disabled = false;
          btn.textContent = oldText;
          return;
        }

        // ✅ Update local cache for this row so future renders show the input
        const row = currentRows.find(r => (r.gtin || '') === gtin);
        if (row) {
          row.pricesByLocation = row.pricesByLocation || {};
          row.pricesByLocation[toLocKey] = {
            ...(row.pricesByLocation[toLocKey] || {}),
            merchant_id: data.toMerchantId || '',
            location_id: data.toLocationId || '',
            variation_id: data.toVariationId || '',
            item_id: data.toItemId || '',
            currency: data.currency || 'USD',
            price: (typeof data.toPrice === 'number' && Number.isFinite(data.toPrice)) ? data.toPrice : null,
            calculated_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };
        }

        // ✅ Swap only this cell to inline price input
        if (td) {
          
          td.innerHTML = '';

          const input = document.createElement('input');
          input.type = 'number';
          input.step = '0.01';
          input.className = 'price-input';

          if (typeof data.toPrice === 'number' && Number.isFinite(data.toPrice)) {
            input.value = Number(data.toPrice).toFixed(2);
          } else {
            input.value = ''; // let user enter
          }

          input.dataset.merchantId = data.toMerchantId || '';
          input.dataset.variationId = data.toVariationId || '';
          input.dataset.currency = data.currency || 'USD';

          input.addEventListener('change', handlePriceChange);
          td.appendChild(input);

          // focus so user can edit immediately
          input.focus();
          input.select();
        }
      } catch (err) {
        console.error(err);
        alert('Copy failed: ' + err.message);
        btn.disabled = false;
        btn.textContent = oldText;
      }
    }



    function renderTable() {
      tbody.innerHTML = '';

      if (currentSort.key) {
        const { key, type, direction } = currentSort;
        const dir = direction === 'asc' ? 1 : -1;

        currentRows.sort((a, b) => {
          const va = a[key];
          const vb = b[key];

          if (type === 'number') {
            const na = va == null || isNaN(va) ? -Infinity : Number(va);
            const nb = vb == null || isNaN(vb) ? -Infinity : Number(vb);
            if (na < nb) return -1 * dir;
            if (na > nb) return 1 * dir;
            return 0;
          } else {
            const sa = (va ?? '').toString().toLowerCase();
            const sb = (vb ?? '').toString().toLowerCase();
            if (sa < sb) return -1 * dir;
            if (sa > sb) return 1 * dir;
            return 0;
          }
        });
      }

      if (!currentRows.length) {
        tbody.innerHTML = `<tr><td colspan="${5 + locationKeys.length}">No GTIN rows found.</td></tr>`;
        const filtersLabel = [
          mismatchOnly ? 'Mismatch only' : 'All',
          missingOnly ? `Missing in ${missingTarget ? locLabel(missingTarget) : '(select store)'}` : null
        ].filter(Boolean).join(' — ');
        pageInfo.textContent = `Page ${currentPageIndex + 1} (${filtersLabel || 'All'} — 0 rows)`;
        prevBtn.disabled = currentPageIndex <= 0;
        nextBtn.disabled = !(pages[currentPageIndex] && pages[currentPageIndex].nextCursor);
        return;
      }

      for (const r of currentRows) {
        const tr = document.createElement('tr');
        if (isMismatchRow(r)) tr.classList.add('mismatch-row');

        // --- delete button ---
        const tdDel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.className = 'btn btn-danger delete-btn';
        delBtn.dataset.gtin = r.gtin || '';
        delBtn.dataset.itemName = r.item_name || '';
        delBtn.addEventListener('click', handleDeleteGtin);
        tdDel.appendChild(delBtn);
        tr.appendChild(tdDel);

        const tdGtin = document.createElement('td');
        tdGtin.textContent = r.gtin;
        tr.appendChild(tdGtin);

        const tdSku = document.createElement('td');
        tdSku.textContent = r.sku || '';
        tr.appendChild(tdSku);

        const tdCat = document.createElement('td');
        tdCat.textContent = r.category_name || '';
        tr.appendChild(tdCat);

        const tdName = document.createElement('td');
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'name-input';
        nameInput.value = r.item_name || '';
        nameInput.dataset.gtin = r.gtin || '';
        nameInput.addEventListener('change', handleNameChange);
        tdName.appendChild(nameInput);
        tr.appendChild(tdName);

        locationKeys.forEach(locKey => {
          const td = document.createElement('td');
          const info = r.pricesByLocation?.[locKey];

          if (info) {
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '0.01';
            input.className = 'price-input';
            if (info.price != null) input.value = Number(info.price).toFixed(2);

            const mid = info.merchant_id || info.merchantId || info.merchant || '';
            const vid = info.variation_id || info.variationId || info.variation || '';

            input.dataset.merchantId = mid;
            input.dataset.variationId = vid;
            input.dataset.currency = info.currency || info.currency_code || 'USD';

            // Optional: if missing ids, visually mark + disable
            if (!mid || !vid) {
              input.disabled = true;
              input.title = 'Missing merchant_id/variation_id in matrix data';
              input.classList.add('price-error');
            }


            input.addEventListener('change', handlePriceChange);
            td.appendChild(input);
          } else {
            // ✅ Missing in this location: show "Copy" action
            const fromLocKey = locationKeys.find(k => r.pricesByLocation?.[k]); // first location that exists
            const btn = document.createElement('button');
            btn.textContent = 'Copy';
            btn.className = 'btn btn-small copy-btn';
            btn.dataset.gtin = r.gtin || '';
            btn.dataset.toLocKey = locKey;
            btn.dataset.fromLocKey = fromLocKey || '';
            btn.addEventListener('click', handleCopyItemInfo);

            // tag td so we can locate it later if needed
            td.dataset.gtin = r.gtin || '';
            td.dataset.locKey = locKey;

            td.appendChild(btn);
          }


          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      }

      const hasNext = pages[currentPageIndex] && pages[currentPageIndex].nextCursor;
      const filtersLabel = [
        mismatchOnly ? 'Mismatch only' : 'All',
        missingOnly ? `Missing in ${missingTarget ? locLabel(missingTarget) : '(select store)'}` : null
      ].filter(Boolean).join(' — ');

      pageInfo.textContent = `Page ${currentPageIndex + 1} (${filtersLabel || 'All'} — rows: ${currentRows.length})`;
      prevBtn.disabled = currentPageIndex <= 0;
      nextBtn.disabled = !hasNext;
    }

    // sorting
    getHeaderCells().forEach(th => {
      th.addEventListener('click', () => sortBy(th.dataset.key, th.dataset.type || 'string'));
    });

    // search
    let searchDebounce = null;
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        clearTimeout(searchDebounce);
        searchDebounce = setTimeout(() => {
          currentQueryRaw = (searchInput.value || '').trim().toLowerCase();
          resetPagingAndLoad();
        }, 250);
      });
    }

    // paging
    rowsPerPageSelect.addEventListener('change', () => {
      rowsPerPage = Number(rowsPerPageSelect.value) || 50;
      resetPagingAndLoad();
    });

    prevBtn.addEventListener('click', () => {
      if (currentPageIndex > 0) loadPage(currentPageIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
      const page = pages[currentPageIndex];
      if (page && page.nextCursor) loadPage(currentPageIndex + 1);
    });

    // --- price update ---
    async function handlePriceChange(event) {
      const input = event.target;
      const newValue = input.value.trim();

      const merchantId = input.dataset.merchantId;
      const variationId = input.dataset.variationId;
      const currency = input.dataset.currency || 'USD';

      if (!merchantId || !variationId) return alert('Missing merchant/variation info.');

      const numericPrice = Number(newValue);
      if (!newValue || Number.isNaN(numericPrice) || numericPrice < 0) {
        input.classList.add('price-error');
        return alert('Enter a valid non-negative price.');
      }

      input.disabled = true;
      input.classList.remove('price-error');

      try {
        const res = await fetch('/api/update-price', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ merchantId, variationId, price: numericPrice, currency }),
        });
        const data = await res.json();
        if (!res.ok || !data.success) throw new Error(data.error || 'Failed to update price');

        input.classList.add('price-updated');
        setTimeout(() => input.classList.remove('price-updated'), 800);
      } catch (err) {
        console.error(err);
        input.classList.add('price-error');
        alert('Failed to update price: ' + err.message);
      } finally {
        input.disabled = false;
      }
    }

    // --- name update ---
    async function handleNameChange(event) {
      const input = event.target;
      const newName = input.value.trim();
      const gtin = input.dataset.gtin;

      if (!gtin) return alert('Missing GTIN.');
      if (!newName) {
        input.classList.add('name-error');
        return alert('Item name cannot be empty.');
      }

      input.disabled = true;
      input.classList.remove('name-error');

      try {
        const res = await fetch('/api/update-item-name', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ gtin, itemName: newName }),
        });
        const data = await res.json();
        if (!res.ok || !data.success) throw new Error(data.error || 'Failed to update item name');

        input.classList.add('name-updated');
        setTimeout(() => input.classList.remove('name-updated'), 800);
      } catch (err) {
        console.error(err);
        input.classList.add('name-error');
        alert('Failed to update item name: ' + err.message);
      } finally {
        input.disabled = false;
      }
    }

    // initial load (global consolidated view)
    (async () => {
      try {
        await loadPage(0);
      } catch (e) {
        console.error(e);
        stopLoading();
        tbody.innerHTML = `<tr><td colspan="4">Failed to load. Check server logs.</td></tr>`;
      }
    })();
  </script>
</body>
</html>
