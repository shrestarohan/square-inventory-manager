<!-- views/dashboard-gtin.ejs
     Price mismatch dashboard (global consolidated view, no merchant dropdown).
     Uses:
       GET /api/gtin-inventory-matrix  -> { rows, locations, nextCursor }
     Server-side filter:
       mismatchOnly=1
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Price Mismatch Dashboard</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <%- include('partials/header', {
        pageTitle: 'GTIN Master Inventory',
        currentView: 'gtin',
        merchant: null,
        merchantId: null,
        merchants: typeof merchants !== 'undefined' ? merchants : [],
        activePage: 'dashboard-gtin',
      }) %>

  <p class="hint">
    Rows highlighted have different prices across locations.
  </p>

  <!-- ✅ Server-side filter UI, don't add here it's added to header.ejs -->

  <table id="inventory-table">
    <thead>
      <tr id="header-row">
        <th>Delete</th>
        <th class="sortable" data-key="gtin" data-type="string">GTIN</th>
        <th class="sortable" data-key="sku" data-type="string">SKU</th>
        <th class="sortable" data-key="category_name" data-type="string">Category</th>
        <th class="sortable" data-key="item_name" data-type="string">Item</th>
        <!-- Location price columns injected by JS -->
      </tr>
    </thead>
    <tbody id="inventory-body"></tbody>
  </table>

  <div class="pagination">
    <span id="page-info"></span>
    <span>
      Rows per page:
      <select id="rowsPerPage">
        <option value="25">25</option>
        <option value="50" selected>50</option>
        <option value="100">100</option>
        <option value="250">250</option>
      </select>
    </span>
    <button id="prevPage">&laquo; Prev</button>
    <button id="nextPage">Next &raquo;</button>
  </div>

  <%- include('partials/footer') %>

  <script>
    // header view switch
    const viewSelect = document.getElementById('viewSelect');
    if (viewSelect) viewSelect.addEventListener('change', () => {
      const val = viewSelect.value;
      if (val) window.location.href = val;
    });

    // loader (from header.ejs)
    const topLoader = document.getElementById('top-loader');
    const topLoaderBar = document.getElementById('top-loader-bar');
    const miniSpinner = document.getElementById('mini-spinner');

    let loaderTimer = null;
    function startLoading() {
      if (topLoader) topLoader.classList.add('is-on');
      if (miniSpinner) miniSpinner.classList.add('is-on');
      if (topLoaderBar) topLoaderBar.style.width = '10%';

      let p = 10;
      clearInterval(loaderTimer);
      loaderTimer = setInterval(() => {
        p = Math.min(p + Math.random() * 12, 92);
        if (topLoaderBar) topLoaderBar.style.width = p.toFixed(0) + '%';
      }, 180);
    }

    function stopLoading() {
      clearInterval(loaderTimer);
      loaderTimer = null;

      if (topLoaderBar) topLoaderBar.style.width = '100%';
      setTimeout(() => {
        if (topLoader) topLoader.classList.remove('is-on');
        if (miniSpinner) miniSpinner.classList.remove('is-on');
        if (topLoaderBar) topLoaderBar.style.width = '0%';
      }, 180);
    }

    // table/paging
    const headerRow = document.getElementById('header-row');
    const tbody = document.getElementById('inventory-body');
    const pageInfo = document.getElementById('page-info');
    const rowsPerPageSelect = document.getElementById('rowsPerPage');
    const prevBtn = document.getElementById('prevPage');
    const nextBtn = document.getElementById('nextPage');
    const searchInput = document.getElementById('search'); // from header partial, optional

    // ✅ server-side mismatch filter
    const mismatchFilterSelect = document.getElementById('mismatchFilter');
    let mismatchOnly = false;

    let locationKeys = [];
    let headerBuilt = false;

    let pages = [];        // [{ rows, nextCursor }]
    let cursors = [null];  // cursor for each page
    let currentPageIndex = 0;
    let rowsPerPage = Number(rowsPerPageSelect.value) || 50;

    let currentRows = [];
    let currentSort = { key: null, direction: 'asc', type: 'string' };
    let inflight = null;

    // backend normalizes "200 ml" -> "200ml"
    let currentQueryRaw = '';

    function resetPagingAndLoad() {
      pages = [];
      cursors = [null];
      currentPageIndex = 0;
      loadPage(0);
    }

    // ✅ Bind mismatch filter AFTER paging vars/functions exist
    if (mismatchFilterSelect) {
      mismatchFilterSelect.addEventListener('change', () => {
        mismatchOnly = mismatchFilterSelect.value === 'mismatch';
        resetPagingAndLoad();
      });
    }

    function renderSkeleton() {
      tbody.innerHTML = '';
      for (let i = 0; i < 10; i++) {
        const tr = document.createElement('tr');
        tr.innerHTML =
          `<td colspan="${5 + (locationKeys?.length || 0)}" ` +
          `style="padding:14px;opacity:.35;">&nbsp;</td>`;
        tbody.appendChild(tr);
      }
    }

    function ensureHeader(locKeys) {
      if (headerBuilt) return;
      locationKeys = Array.isArray(locKeys) ? locKeys : [];
      locationKeys.forEach(locKey => {
        const th = document.createElement('th');
        th.textContent = locKey + ' (Price)';
        headerRow.appendChild(th);
      });
      headerBuilt = true;
    }

    function getHeaderCells() {
      return Array.from(document.querySelectorAll('#inventory-table thead th.sortable'));
    }

    function clearSortIndicators() {
      getHeaderCells().forEach(th => th.classList.remove('sorted-asc', 'sorted-desc'));
    }

    function sortBy(key, type) {
      if (!key) return;
      if (currentSort.key === key) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.key = key;
        currentSort.direction = 'asc';
      }
      currentSort.type = type || 'string';

      clearSortIndicators();
      getHeaderCells().forEach(th => {
        if (th.dataset.key === key) {
          th.classList.add(currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
      });

      renderTable();
    }

    async function fetchPage(pageIndexToLoad) {
      const cursor = cursors[pageIndexToLoad] || null;

      const params = new URLSearchParams();
      params.set('pageSize', String(rowsPerPage));
      if (cursor) params.set('cursor', cursor);
      if (currentQueryRaw) params.set('q', currentQueryRaw);

      // ✅ server-side mismatch filter param
      if (mismatchOnly) params.set('mismatchOnly', '1');

      const url = '/api/gtin-inventory-matrix?' + params.toString();

      if (inflight) inflight.abort();
      inflight = new AbortController();

      startLoading();

      const res = await fetch(url, {
        headers: { 'Accept': 'application/json' },
        signal: inflight.signal,
      });

      if (!res.ok) throw new Error(await res.text());
      const data = await res.json();

      if (!headerBuilt && data.locations) ensureHeader(data.locations);

      const rows = (data.rows || []).map(r => ({
        gtin: r.gtin || '',
        item_name: r.item_name || '',
        category_name: r.category_name || '',
        sku: r.sku || '',
        pricesByLocation: r.pricesByLocation || {},
      }));

      pages[pageIndexToLoad] = { rows, nextCursor: data.nextCursor || null };
      cursors[pageIndexToLoad + 1] = data.nextCursor || null;

      stopLoading();
      return rows;
    }

    async function loadPage(pageIndex) {
      currentPageIndex = pageIndex;

      if (!pages[pageIndex]) {
        renderSkeleton();
        await fetchPage(pageIndex);
      }

      currentRows = (pages[pageIndex]?.rows || []).slice();
      renderTable();
    }

    async function handleDeleteGtin(event) {
      const btn = event.target;
      const gtin = (btn.dataset.gtin || '').trim();
      const itemName = (btn.dataset.itemName || '').trim();

      if (!gtin) return alert('Missing GTIN.');

      const ok = confirm(
        `Delete this item everywhere?\n\nGTIN: ${gtin}\nItem: ${itemName || '(no name)'}\n\nThis will remove it from Firestore and Square for each merchant where present.`
      );
      if (!ok) return;

      btn.disabled = true;

      try {
        // ✅ Use the SAME endpoint your dashboard uses.
        // If your dashboard endpoint is different, change this URL to match it.
        const res = await fetch('/api/delete-item', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ gtin }),
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.success) throw new Error(data.error || 'Delete failed');

        // ✅ Remove the deleted row from cached pages so it disappears immediately
        for (const p of pages) {
          if (!p || !p.rows) continue;
          p.rows = p.rows.filter(row => row.gtin !== gtin);
        }
        currentRows = currentRows.filter(row => row.gtin !== gtin);

        renderTable();

        // Optional: if you prefer a full refresh (slower but simplest)
        // resetPagingAndLoad();

      } catch (err) {
        console.error(err);
        alert('Failed to delete: ' + err.message);
      } finally {
        btn.disabled = false;
      }
    }


    // Used only for row highlighting
    function isMismatchRow(r) {
      const prices = [];
      for (const locKey of locationKeys) {
        const info = r.pricesByLocation?.[locKey];
        if (info && typeof info.price === 'number') prices.push(info.price);
      }
      if (prices.length <= 1) return false;
      const first = prices[0];
      return prices.some(p => Math.abs(p - first) > 0.0001);
    }

    function renderTable() {
      tbody.innerHTML = '';

      if (currentSort.key) {
        const { key, type, direction } = currentSort;
        const dir = direction === 'asc' ? 1 : -1;

        currentRows.sort((a, b) => {
          const va = a[key];
          const vb = b[key];

          if (type === 'number') {
            const na = va == null || isNaN(va) ? -Infinity : Number(va);
            const nb = vb == null || isNaN(vb) ? -Infinity : Number(vb);
            if (na < nb) return -1 * dir;
            if (na > nb) return 1 * dir;
            return 0;
          } else {
            const sa = (va ?? '').toString().toLowerCase();
            const sb = (vb ?? '').toString().toLowerCase();
            if (sa < sb) return -1 * dir;
            if (sa > sb) return 1 * dir;
            return 0;
          }
        });
      }

      if (!currentRows.length) {
        tbody.innerHTML = `<tr><td colspan="${5 + locationKeys.length}">No GTIN rows found.</td></tr>`;
        pageInfo.textContent = `Page ${currentPageIndex + 1} (${mismatchOnly ? 'Mismatch only' : 'All'} — 0 rows)`;
        prevBtn.disabled = currentPageIndex <= 0;
        nextBtn.disabled = !(pages[currentPageIndex] && pages[currentPageIndex].nextCursor);
        return;
      }

      for (const r of currentRows) {
        const tr = document.createElement('tr');
        if (isMismatchRow(r)) tr.classList.add('mismatch-row');

        // --- delete button (last column) ---
        const tdDel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.className = 'btn btn-danger delete-btn';
        delBtn.dataset.gtin = r.gtin || '';
        delBtn.dataset.itemName = r.item_name || '';
        delBtn.addEventListener('click', handleDeleteGtin);
        tdDel.appendChild(delBtn);
        tr.appendChild(tdDel);

        const tdGtin = document.createElement('td');
        tdGtin.textContent = r.gtin;
        tr.appendChild(tdGtin);

        const tdSku = document.createElement('td');
        tdSku.textContent = r.sku || '';
        tr.appendChild(tdSku);
        
        const tdCat = document.createElement('td');
        tdCat.textContent = r.category_name || '';
        tr.appendChild(tdCat);

        const tdName = document.createElement('td');
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'name-input';
        nameInput.value = r.item_name || '';
        nameInput.dataset.gtin = r.gtin || '';
        nameInput.addEventListener('change', handleNameChange);
        tdName.appendChild(nameInput);
        tr.appendChild(tdName);

        locationKeys.forEach(locKey => {
          const td = document.createElement('td');
          const info = r.pricesByLocation?.[locKey];

          if (info) {
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '0.01';
            input.className = 'price-input';
            if (info.price != null) input.value = Number(info.price).toFixed(2);

            input.dataset.merchantId = info.merchant_id || '';
            input.dataset.variationId = info.variation_id || '';
            input.dataset.currency = info.currency || 'USD';

            input.addEventListener('change', handlePriceChange);
            td.appendChild(input);
          } else {
            td.textContent = '';
          }

          tr.appendChild(td);

        });

        tbody.appendChild(tr);
      }

      const hasNext = pages[currentPageIndex] && pages[currentPageIndex].nextCursor;
      pageInfo.textContent = `Page ${currentPageIndex + 1} (${mismatchOnly ? 'Mismatch only' : 'All'} — rows: ${currentRows.length})`;
      prevBtn.disabled = currentPageIndex <= 0;
      nextBtn.disabled = !hasNext;
    }

    // sorting
    getHeaderCells().forEach(th => {
      th.addEventListener('click', () => sortBy(th.dataset.key, th.dataset.type || 'string'));
    });

    // search
    let searchDebounce = null;
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        clearTimeout(searchDebounce);
        searchDebounce = setTimeout(() => {
          currentQueryRaw = (searchInput.value || '').trim().toLowerCase();
          resetPagingAndLoad();
        }, 250);
      });
    }

    // paging
    rowsPerPageSelect.addEventListener('change', () => {
      rowsPerPage = Number(rowsPerPageSelect.value) || 50;
      resetPagingAndLoad();
    });

    prevBtn.addEventListener('click', () => {
      if (currentPageIndex > 0) loadPage(currentPageIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
      const page = pages[currentPageIndex];
      if (page && page.nextCursor) loadPage(currentPageIndex + 1);
    });

    // --- price update ---
    async function handlePriceChange(event) {
      const input = event.target;
      const newValue = input.value.trim();

      const merchantId = input.dataset.merchantId;
      const variationId = input.dataset.variationId;
      const currency = input.dataset.currency || 'USD';

      if (!merchantId || !variationId) return alert('Missing merchant/variation info.');

      const numericPrice = Number(newValue);
      if (!newValue || Number.isNaN(numericPrice) || numericPrice < 0) {
        input.classList.add('price-error');
        return alert('Enter a valid non-negative price.');
      }

      input.disabled = true;
      input.classList.remove('price-error');

      try {
        const res = await fetch('/api/update-price', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ merchantId, variationId, price: numericPrice, currency }),
        });
        const data = await res.json();
        if (!res.ok || !data.success) throw new Error(data.error || 'Failed to update price');

        input.classList.add('price-updated');
        setTimeout(() => input.classList.remove('price-updated'), 800);
      } catch (err) {
        console.error(err);
        input.classList.add('price-error');
        alert('Failed to update price: ' + err.message);
      } finally {
        input.disabled = false;
      }
    }

    // --- name update ---
    async function handleNameChange(event) {
      const input = event.target;
      const newName = input.value.trim();
      const gtin = input.dataset.gtin;

      if (!gtin) return alert('Missing GTIN.');
      if (!newName) {
        input.classList.add('name-error');
        return alert('Item name cannot be empty.');
      }

      input.disabled = true;
      input.classList.remove('name-error');

      try {
        const res = await fetch('/api/update-item-name', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ gtin, itemName: newName }),
        });
        const data = await res.json();
        if (!res.ok || !data.success) throw new Error(data.error || 'Failed to update item name');

        input.classList.add('name-updated');
        setTimeout(() => input.classList.remove('name-updated'), 800);
      } catch (err) {
        console.error(err);
        input.classList.add('name-error');
        alert('Failed to update item name: ' + err.message);
      } finally {
        input.disabled = false;
      }
    }

    // initial load (global consolidated view)
    (async () => {
      try {
        await loadPage(0);
      } catch (e) {
        console.error(e);
        stopLoading();
        tbody.innerHTML = `<tr><td colspan="4">Failed to load. Check server logs.</td></tr>`;
      }
    })();
  </script>
</body>
</html>
