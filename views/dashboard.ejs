<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Inventory Dashboard</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <%- include('partials/header', {
        pageTitle: 'Inventory Dashboard',
        currentView: 'item',
        merchant: typeof merchant !== 'undefined' ? merchant : null,
        merchantId: typeof merchantId !== 'undefined' ? merchantId : null,
        merchants: typeof merchants !== 'undefined' ? merchants : [],
        activePage: 'dashboard'
      }) %>

  <div style="display:flex;gap:10px;align-items:center;margin:10px 0;">
    <label style="display:flex;gap:8px;align-items:center;">
      <input type="checkbox" id="onlyNoCategory" />
      Only show items with no category
    </label>

    <button id="clearCategoryCacheBtn" type="button" class="btn btn-sm">
      Clear category cache
    </button>
  </div>

  <table id="inventory-table">
    <thead>
      <tr>
        <th>Image</th>
        <th class="sortable" data-key="merchant_name" data-type="string">Merchant</th>
        <th class="sortable" data-key="location_name" data-type="string">Location</th>
        <th class="sortable" data-key="category_name" data-type="string">Category</th>
        <th class="sortable" data-key="item_name" data-type="string">Item</th>
        <th class="sortable" data-key="variation_name" data-type="string">Variation</th>
        <th class="sortable" data-key="sku" data-type="string">SKU</th>
        <th class="sortable" data-key="gtin" data-type="string">GTIN</th>
        <th class="sortable" data-key="qty" data-type="number">Qty</th>
        <th class="sortable" data-key="state" data-type="string">State</th>
        <th class="sortable" data-key="price" data-type="number">Price</th>
        <th class="sortable" data-key="calculated_at" data-type="string">Updated</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="inventory-body"></tbody>
  </table>

  <div class="pagination">
    <span id="page-info"></span>
    <span>
      Rows per page:
      <select id="rowsPerPage">
        <option value="25">25</option>
        <option value="50" selected>50</option>
        <option value="100">100</option>
        <option value="250">250</option>
      </select>
    </span>
    <button id="prevPage">&laquo; Prev</button>
    <button id="nextPage">Next &raquo;</button>
  </div>

  <%- include('partials/footer') %>

  <script>
    // ---------- header controls ----------
    const merchantSelect = document.getElementById('merchantSelect');
    if (merchantSelect) merchantSelect.addEventListener('change', () => {
      const val = "/dashboard/" + merchantSelect.value;
      if (val) window.location.href = val;
    });

    const viewSelect = document.getElementById('viewSelect');
    if (viewSelect) viewSelect.addEventListener('change', () => {
      const val = viewSelect.value;
      if (val) window.location.href = val;
    });

    // ---------- loader elements (from header.ejs) ----------
    const topLoader = document.getElementById('top-loader');
    const topLoaderBar = document.getElementById('top-loader-bar');
    const miniSpinner = document.getElementById('mini-spinner');
    const loadStatus = document.getElementById('load-status');

    function setStatus(msg) {
      if (loadStatus) loadStatus.textContent = (msg ?? '');
    }

    let loaderTimer = null;
    function startLoading(label) {
      setStatus(label ?? '');
      if (topLoader) topLoader.classList.add('is-on');
      if (miniSpinner) miniSpinner.classList.add('is-on');

      if (topLoaderBar) topLoaderBar.style.width = '10%';
      let p = 10;

      clearInterval(loaderTimer);
      loaderTimer = setInterval(() => {
        p = Math.min(p + Math.random() * 12, 92);
        if (topLoaderBar) topLoaderBar.style.width = p.toFixed(0) + '%';
      }, 180);
    }

    function stopLoading() {
      clearInterval(loaderTimer);
      loaderTimer = null;

      if (topLoaderBar) topLoaderBar.style.width = '100%';
      setTimeout(() => {
        if (topLoader) topLoader.classList.remove('is-on');
        if (miniSpinner) miniSpinner.classList.remove('is-on');
        if (topLoaderBar) topLoaderBar.style.width = '0%';
        setStatus('');
      }, 180);
    }

    // ---------- Inline editing helpers ----------
    function normStr(s) { return (s ?? '').toString().trim(); }

    function parsePrice(val) {
      const s = normStr(val).replace(/[^0-9.]/g, '');
      if (!s) return null;
      const n = Number(s);
      if (!isFinite(n)) return null;
      return Math.round(n * 100) / 100;
    }

    function validateField(field, value) {
      if (field === 'gtin') {
        const v = normStr(value).replace(/\s+/g, '');
        // allow blank (clear)
        if (!v) return { ok: true, value: '' };
        // digits only, common GTIN lengths 8-14, but allow up to 20 if you want
        if (!/^\d+$/.test(v)) return { ok: false, error: 'GTIN must be digits only.' };
        if (v.length < 8 || v.length > 20) return { ok: false, error: 'GTIN length looks invalid.' };
        return { ok: true, value: v };
      }

      if (field === 'sku') {
        // allow anything but trim
        return { ok: true, value: normStr(value) };
      }

      if (field === 'item_name') {
        const v = normStr(value);
        if (!v) return { ok: false, error: 'Item name cannot be empty.' };
        return { ok: true, value: v };
      }

      if (field === 'price') {
        const n = parsePrice(value);
        if (n === null) return { ok: false, error: 'Price must be a number.' };
        if (n < 0) return { ok: false, error: 'Price cannot be negative.' };
        return { ok: true, value: n };
      }

      return { ok: false, error: 'Unknown field.' };
    }

    async function updateItemFields({ merchantId, itemId, variationId, updates }) {
      const res = await fetch('/api/items/update-fields', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify({ merchantId, itemId, variationId, updates }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data.success) throw new Error(data.error || 'Update failed');
      return data;
    }

    /**
     * Makes a table cell inline-editable.
     * - td: <td>
     * - r: row object (your mapped row)
     * - opts.field: 'item_name' | 'gtin' | 'sku' | 'price'
     * - opts.get(): returns current display value
     * - opts.set(value): mutates r with new value
     */
    function makeInlineEditable(td, r, opts) {
      td.classList.add('is-clickable');
      td.title = 'Click to edit';

      // Prevent stacking multiple click listeners on re-render
      td.addEventListener('click', () => openInlineEditor(td, r, opts), { once: true });
    }

    async function openInlineEditor(td, r, opts) {
      if (td.dataset.editing === '1') return;
      td.dataset.editing = '1';

      const { field } = opts;
      const originalDisplay = (opts.get ? opts.get() : '') ?? '';
      const originalRaw = originalDisplay;

      td.classList.add('is-editing');
      td.innerHTML = '';

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'inline-input';
      input.value = (field === 'price' && originalDisplay !== '' && originalDisplay != null)
        ? String(originalDisplay)
        : String(originalDisplay || '');
      td.appendChild(input);

      const close = (reRender = true) => {
        td.dataset.editing = '0';
        td.classList.remove('is-editing', 'is-saving');
            if (reRender) {
              // caller should re-render the entire row or just set textContent
              // We'll just restore text now; your renderTable will rebuild anyway
              td.textContent = (opts.get ? opts.get() : '') ?? '';
              makeInlineEditable(td, r, opts); // re-arm click
            }
          };

          const commit = async () => {
            const nextRaw = input.value;

            const v = validateField(field, nextRaw);
            if (!v.ok) {
              alert(v.error);
              input.focus();
              input.select();
              return;
            }

            // no change
            const nextVal = v.value;
            const same =
              (field === 'price')
                ? Number(nextVal) === Number(parsePrice(originalRaw))
                : String(nextVal) === String(originalRaw);

            if (same) return close(true);

            input.disabled = true;
            td.classList.add('is-saving');

            try {
              startLoading('');

              const updates = {};
              updates[field] = nextVal;

              // required IDs
              if (!r.merchant_id || !r.item_id) throw new Error('Missing merchant_id / item_id in row');
              const resp = await updateItemFields({
                merchantId: r.merchant_id,
                itemId: r.item_id,
                variationId: r.variation_id || null,
                updates,
              });

              // Apply returned values if server normalizes them
              const applied = resp.updated || updates;

              if (opts.set) opts.set(applied[field] ?? nextVal);

              td.classList.add('is-saved');
              setTimeout(() => td.classList.remove('is-saved'), 600);

              close(true);
            } catch (e) {
              console.error(e);
              alert(`Update failed: ${e.message}`);
              // revert
              if (opts.set) opts.set(originalDisplay);
              close(true);
            } finally {
              stopLoading();
            }
          };

          input.focus();
          input.select();

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); commit(); }
            if (e.key === 'Escape') { e.preventDefault(); close(true); }
          });

          input.addEventListener('blur', () => commit());
        }
      
    // ---------- API helpers ----------
    async function renameCategory({ merchantId, categoryId, newName }) {
      const res = await fetch('/api/categories/rename', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify({ merchantId, categoryId, newName }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data.success) throw new Error(data.error || 'Rename failed');
      return data;
    }

    function clearCategoryCache(merchantId = null) {
      if (merchantId) categoryCache.delete(merchantId);
      else categoryCache.clear();
    }

    const clearCategoryCacheBtn = document.getElementById('clearCategoryCacheBtn');
    if (clearCategoryCacheBtn) {
      clearCategoryCacheBtn.addEventListener('click', () => {
        clearCategoryCache();       // ✅ clears all merchants
        // optional: also drop any open editor state if needed
        alert('Category cache cleared. Next time you open a category dropdown it will re-fetch.');
      });
    }

    // --- category dropdown cache (per merchant) ---
    const categoryCache = new Map(); // merchantId -> [{categoryId,name},...]

    async function fetchCategoriesForMerchant(merchantId) {
      if (!merchantId) return [];
      if (categoryCache.has(merchantId)) return categoryCache.get(merchantId);

      const res = await fetch('/api/categories?merchantId=' + encodeURIComponent(merchantId), {
        headers: { 'Accept': 'application/json' },
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data.success) throw new Error(data.error || 'Failed to load categories');

      const cats = Array.isArray(data.categories) ? data.categories : [];
      categoryCache.set(merchantId, cats);
      return cats;
    }

    async function setItemCategoryId({ merchantId, itemId, categoryId, categoryName }) {
      const res = await fetch('/api/items/set-category-id', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify({ merchantId, itemId, categoryId, categoryName }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data.success) throw new Error(data.error || 'Set category failed');
      return data;
    }

    // ---------- Category UI (button when missing; click-to-edit when present) ----------
    function makeCategoryDisplayText(r) {
      const t = (r.category_name || '').trim();
      return t ? t : '';
    }

    function renderCategoryCell(td, r) {
      td.innerHTML = '';
      td.className = 'category-cell';

      const canSet = !!(r.merchant_id && r.item_id);
      const label = makeCategoryDisplayText(r);

      if (!label) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'btn btn-sm';
        btn.textContent = 'Set category';
        if (!canSet) btn.disabled = true;

        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          openCategoryEditor(td, r);
        });

        td.appendChild(btn);
        return;
      }

      const span = document.createElement('span');
      span.className = 'category-display';
      span.textContent = label;
      td.appendChild(span);

      if (canSet) {
        td.classList.add('is-clickable');
        td.title = 'Click to change category';
        td.addEventListener('click', () => openCategoryEditor(td, r), { once: true });
      }
    }

    async function openCategoryEditor(td, r) {
      if (td.dataset.editing === '1') return;
      td.dataset.editing = '1';

      const canSet = !!(r.merchant_id && r.item_id);
      if (!canSet) { td.dataset.editing = '0'; return; }

      const originalId = r.category_id || '';
      const originalName = r.category_name || '';

      td.classList.add('is-editing');
      td.innerHTML = '';

      const select = document.createElement('select');
      select.className = 'inline-select';
      select.disabled = true;

      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = 'Select category...';
      select.appendChild(opt0);

      td.appendChild(select);

      const close = () => {
        td.dataset.editing = '0';
        td.classList.remove('is-editing', 'is-saving');
        renderCategoryCell(td, r);
      };

      try {
        const cats = await fetchCategoriesForMerchant(r.merchant_id);

        cats.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c.categoryId;
          opt.textContent = c.name;
          select.appendChild(opt);
        });

        if (r.category_id) select.value = r.category_id;
        else if (r.category_name) {
          const match = cats.find(c => (c.name || '').toLowerCase() === (r.category_name || '').toLowerCase());
          if (match) select.value = match.categoryId;
        }

        select.disabled = false;
        select.focus();

        select.addEventListener('change', async () => {
          const nextId = select.value;
          if (!nextId) return;

          const nextName = select.options[select.selectedIndex]?.textContent || '';

          select.disabled = true;
          td.classList.add('is-saving');

          try {
            startLoading('');

            const resp = await setItemCategoryId({
              merchantId: r.merchant_id,
              itemId: r.item_id,
              categoryId: nextId,
              categoryName: nextName,
            });

            r.category_id = resp.categoryId || nextId;
            r.category_name = resp.categoryName || nextName;

            td.classList.add('is-saved');
            setTimeout(() => td.classList.remove('is-saved'), 600);

            close();
          } catch (e) {
            console.error(e);
            alert('Set category failed: ' + e.message);

            r.category_id = originalId;
            r.category_name = originalName;
            close();
          } finally {
            stopLoading();
          }
        });

        select.addEventListener('blur', () => close());
        select.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') close();
        });

      } catch (e) {
        console.error('Failed to load categories', e);
        close();
      }
    }

    // ---------- Data & table state ----------
    const DASHBOARD_MERCHANT_ID = <%- JSON.stringify(merchantId || null) %>;

    let pages = [];
    let cursors = [null];
    let currentPageIndex = 0;
    let rowsPerPage = 50;

    const tbody = document.getElementById('inventory-body');
    const pageInfo = document.getElementById('page-info');
    const rowsPerPageSelect = document.getElementById('rowsPerPage');
    const prevBtn = document.getElementById('prevPage');
    const nextBtn = document.getElementById('nextPage');
    const headerCells = Array.from(document.querySelectorAll('#inventory-table thead th.sortable'));

    const searchInput = document.getElementById('search');
    let currentQuery = '';

    // ---------- search (from header.ejs) ----------
    function debounce(fn, ms = 250) {
      let t = null;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
      };
    }

    function setQueryAndReload(nextQ) {
      currentQuery = (nextQ || '').trim();
      resetAndReload();
    }

    if (searchInput) {
      // optional: load from URL (?q=...) if you want
      const urlQ = new URLSearchParams(window.location.search).get('q');
      if (urlQ && !currentQuery) {
        currentQuery = urlQ;
        searchInput.value = urlQ;
      }

      const onType = debounce(() => setQueryAndReload(searchInput.value), 300);

      // live search while typing
      searchInput.addEventListener('input', onType);

      // Enter = immediate search
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          setQueryAndReload(searchInput.value);
        }
        // Escape clears
        if (e.key === 'Escape') {
          e.preventDefault();
          searchInput.value = '';
          setQueryAndReload('');
        }
      });
    } else {
      console.warn("⚠️ header search input not found. Expected id='search' in header.ejs");
    }
    
    // ✅ server-side filter state
    const onlyNoCategoryToggle = document.getElementById('onlyNoCategory');
    let onlyNoCategory = false;

    if (onlyNoCategoryToggle) {
      onlyNoCategoryToggle.addEventListener('change', () => {
        onlyNoCategory = !!onlyNoCategoryToggle.checked;
        resetAndReload();
      });
    }

    let currentRows = [];
    let currentSort = { key: null, direction: 'asc', type: 'string' };

    let inflight = null;

    function mapRow(r, idx) {
      return {
        _index: idx,
        id: r.id || r.docId || '',
        merchant_name: r.merchant_name || r.merchant_id || '',
        location_name: r.location_name || r.location_id || '',
        category_name: r.category_name || '',
        category_id: r.category_id || r.categoryId || '',
        item_name: r.item_name || '',
        variation_name: r.variation_name || '',
        sku: r.sku || '',
        gtin: r.gtin || '',
        qty: (r.qty !== undefined && r.qty !== null) ? Number(r.qty) : null,
        state: r.state || '',
        price: (r.price !== undefined && r.price !== null) ? Number(r.price) : null,
        currency: r.currency || '',
        tax_names: Array.isArray(r.tax_names) ? r.tax_names : [],
        tax_percentages: Array.isArray(r.tax_percentages) ? r.tax_percentages : [],
        calculated_at: r.calculated_at || r.updated_at || '',
        image_urls: Array.isArray(r.image_urls) ? r.image_urls : (r.image_urls ? [r.image_urls] : []),
        merchant_id: r.merchant_id || '',
        variation_id: r.variation_id || '',
        item_id: r.item_id || '',
      };
    }

    function renderSkeleton() {
      tbody.innerHTML = '';
      for (let i = 0; i < 8; i++) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="15" style="padding:14px;opacity:.55;">&nbsp;</td>`;
        tbody.appendChild(tr);
      }
    }

    async function fetchPage(pageIndexToLoad) {
      const cursor = cursors[pageIndexToLoad] || null;

      const params = new URLSearchParams();
      params.set('pageSize', String(rowsPerPage));
      if (DASHBOARD_MERCHANT_ID) params.set('merchantId', DASHBOARD_MERCHANT_ID);
      if (cursor) params.set('cursor', cursor);

      if (currentQuery) params.set('q', currentQuery);

      // ✅ server-side filter param
      if (onlyNoCategory) params.set('onlyNoCategory', '1');

      const url = '/api/inventory?' + params.toString();

      if (inflight) inflight.abort();
      inflight = new AbortController();

      startLoading('');

      try {
        const res = await fetch(url, {
          headers: { 'Accept': 'application/json' },
          signal: inflight.signal,
        });

        if (!res.ok) {
          const txt = await res.text();
          throw new Error('Failed to load inventory: ' + txt);
        }

        const data = await res.json().catch(() => ({}));
        const mapped = (data.rows || []).map(mapRow);
        const nextCursor = data.nextCursor || null;

        pages[pageIndexToLoad] = { rows: mapped, nextCursor };
        cursors[pageIndexToLoad + 1] = nextCursor;

        return mapped;
      } catch (e) {
        if (e && e.name === 'AbortError') return null;
        throw e;
      } finally {
        stopLoading();
      }
    }

    async function loadPage(pageIndex) {
      currentPageIndex = pageIndex;

      if (!pages[pageIndex]) {
        renderSkeleton();
        await fetchPage(pageIndex);
      }

      let pageRows = (pages[pageIndex]?.rows || []).slice();

      if (currentSort.key) {
        const { key, type, direction } = currentSort;
        const dir = direction === 'asc' ? 1 : -1;

        pageRows.sort((a, b) => {
          const va = a[key];
          const vb = b[key];
          if (type === 'number') {
            const na = (va === null || va === undefined || isNaN(va)) ? -Infinity : Number(va);
            const nb = (vb === null || vb === undefined || isNaN(vb)) ? -Infinity : Number(vb);
            return na < nb ? -1 * dir : na > nb ? 1 * dir : 0;
          } else {
            const sa = (Array.isArray(va) ? va.join(', ') : (va ?? '')).toString().toLowerCase();
            const sb = (Array.isArray(vb) ? vb.join(', ') : (vb ?? '')).toString().toLowerCase();
            return sa < sb ? -1 * dir : sa > sb ? 1 * dir : 0;
          }
        });
      }

      currentRows = pageRows;
      renderTable();
    }

    function renderTable() {
      tbody.innerHTML = '';

      if (!currentRows.length) {
        tbody.innerHTML = '<tr><td colspan="15">No inventory rows found.</td></tr>';
        pageInfo.textContent = `Page ${currentPageIndex + 1} (0 rows)`;
        prevBtn.disabled = currentPageIndex <= 0;
        nextBtn.disabled = !(pages[currentPageIndex] && pages[currentPageIndex].nextCursor);
        return;
      }

      currentRows.forEach(r => {
        const tr = document.createElement('tr');

        const taxText =
          r.tax_names && r.tax_names.length
            ? r.tax_names.join(', ') +
              (r.tax_percentages && r.tax_percentages.length
                ? ' (' + r.tax_percentages.join(', ') + ' %)'
                : '')
            : '';

        // Image
        const imgTd = document.createElement('td');
        imgTd.className = 'thumb-cell';

        const wrap = document.createElement('div');
        wrap.className = 'thumb-wrap';

        const img = document.createElement('img');
        img.className = 'thumb-img clickable';
        img.loading = 'lazy';
        img.alt = r.item_name || 'Item image';

        const hasImg = r.image_urls && r.image_urls.length;
        const PLACEHOLDER_SVG = "data:image/svg+xml;utf8," + encodeURIComponent(`
        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80">
          <rect width="100%" height="100%" rx="10" ry="10" fill="#f2f2f2"/>
          <path d="M40 24v32M24 40h32" stroke="#9aa0a6" stroke-width="4" stroke-linecap="round"/>
        </svg>
        `);
        img.src = hasImg ? r.image_urls[0] : PLACEHOLDER_SVG;

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.style.display = 'none';

        img.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', async () => {
          const file = fileInput.files && fileInput.files[0];
          if (!file) return;

          try {
            startLoading('');
            const previewUrl = URL.createObjectURL(file);
            img.src = previewUrl;

            const fd = new FormData();
            fd.append('image', file);
            if (r.gtin) fd.append('gtin', r.gtin);
            if (r.merchant_id) fd.append('merchantId', r.merchant_id);
            if (r.item_id) fd.append('itemId', r.item_id);

            const res = await fetch('/api/update-item-image', { method: 'POST', body: fd });
            const data = await res.json().catch(() => ({}));

            if (!res.ok || data.ok === false) {
              // include useful server payload when available
              const msg =
                data?.error ||
                (data?.results && Array.isArray(data.results)
                  ? data.results.filter(r => r.ok === false).map(r => r.error).join(" | ")
                  : null) ||
                'Upload failed';
              throw new Error(msg + (data ? `: ${JSON.stringify(data)}` : ''));
            }

            // ✅ success
            if (data.firstImageUrl) img.src = data.firstImageUrl;
            img.classList.add('thumb-updated');
            setTimeout(() => img.classList.remove('thumb-updated'), 800);
          } catch (e) {
            console.error(e);
            alert('Image update failed: ' + e.message);
            img.src = hasImg ? r.image_urls[0] : PLACEHOLDER_SVG;
          } finally {
            stopLoading();
            fileInput.value = '';
          }
        });

        wrap.appendChild(img);
        wrap.appendChild(fileInput);
        imgTd.appendChild(wrap);
        tr.appendChild(imgTd);

        // Merchant
        let td = document.createElement('td');
        td.textContent = r.merchant_name;
        tr.appendChild(td);

        // Location
        td = document.createElement('td');
        td.textContent = r.location_name;
        tr.appendChild(td);

        // Category
        td = document.createElement('td');
        renderCategoryCell(td, r);
        tr.appendChild(td);

        // Item
        td = document.createElement('td');
        td.textContent = r.item_name;
        makeInlineEditable(td, r, {
          field: 'item_name',
          get: () => r.item_name || '',
          set: (v) => { r.item_name = (v ?? '').toString(); }
        });
        tr.appendChild(td);

        // Variation
        td = document.createElement('td');
        td.textContent = r.variation_name;
        tr.appendChild(td);

        // SKU
        td = document.createElement('td');
        td.textContent = r.sku || '';
        makeInlineEditable(td, r, {
          field: 'sku',
          get: () => r.sku || '',
          set: (v) => { r.sku = (v ?? '').toString(); }
        });
        tr.appendChild(td);

        // GTIN
        td = document.createElement('td');
        td.textContent = r.gtin || '';
        makeInlineEditable(td, r, {
          field: 'gtin',
          get: () => r.gtin || '',
          set: (v) => { r.gtin = (v ?? '').toString(); }
        });
        tr.appendChild(td);

        // Qty
        td = document.createElement('td');
        td.textContent = (r.qty !== null && r.qty !== undefined) ? Number(r.qty).toFixed(0) : '';
        makeInlineEditable(td, r, {
          field: 'qty',
          get: () => (r.qty !== null && r.qty !== undefined) ? Number(r.qty).toFixed(0) : '',
          set: (v) => { r.qty = (v === '' || v == null) ? null : Number(v); }
        });
        tr.appendChild(td);

        // State
        td = document.createElement('td');
        td.textContent = r.state;
        tr.appendChild(td);

        // Price
        td = document.createElement('td');
        td.textContent = (r.price !== null && r.price !== undefined) ? Number(r.price).toFixed(2) : '';
        makeInlineEditable(td, r, {
          field: 'price',
          get: () => (r.price !== null && r.price !== undefined) ? Number(r.price).toFixed(2) : '',
          set: (v) => { r.price = (v === '' || v == null) ? null : Number(v); }
        });
        tr.appendChild(td);

        // Updated
        td = document.createElement('td');
        td.textContent = r.calculated_at;
        tr.appendChild(td);

        // Actions
        const tdActions = document.createElement('td');

        const delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.className = 'btn btn-sm btn-danger';
        delBtn.addEventListener('click', async () => {
          const merchantId = r.merchant_id;
          const variationId = r.variation_id;
          const itemId = r.item_id;

          if (!r.gtin) {
            alert('Missing GTIN for this row. Cannot delete reliably.');
            return;
          }

          if (!merchantId || !variationId) {
            alert('Missing merchant/variation id for this row.');
            return;
          }

          const ok = confirm(
            `Delete this item from Square + Firestore?\n\nMerchant: ${r.merchant_name}\nItem: ${r.item_name}\nGTIN: ${r.gtin}\n\nThis is irreversible.`
          );
          if (!ok) return;

          delBtn.disabled = true;
          try {
            startLoading('');
            const res = await fetch('/api/delete-item', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ gtin: r.gtin || '', merchantId, variationId, itemId, mode: 'variation' }),
            });

            const data = await res.json().catch(() => ({}));
            if (!res.ok || !data.success) throw new Error(data.error || 'Delete failed');

            tr.remove();
          } catch (e) {
            console.error(e);
            alert('Delete failed: ' + e.message);
          } finally {
            stopLoading();
            delBtn.disabled = false;
          }
        });

        tdActions.appendChild(delBtn);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      });

      const hasNext = pages[currentPageIndex] && pages[currentPageIndex].nextCursor;
      pageInfo.textContent = `Page ${currentPageIndex + 1} (rows: ${currentRows.length}${onlyNoCategory ? ', no-category only' : ''})`;
      prevBtn.disabled = currentPageIndex <= 0;
      nextBtn.disabled = !hasNext;
    }

    // sorting UI
    function clearSortIndicators() {
      headerCells.forEach(th => th.classList.remove('sorted-asc', 'sorted-desc'));
    }
    function sortBy(key, type) {
      if (!key) return;
      if (currentSort.key === key) currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      else { currentSort.key = key; currentSort.direction = 'asc'; }
      currentSort.type = type || 'string';

      clearSortIndicators();
      headerCells.forEach(th => {
        if (th.dataset.key === key) th.classList.add(currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
      });

      loadPage(currentPageIndex);
    }
    headerCells.forEach(th => th.addEventListener('click', () => sortBy(th.dataset.key, th.dataset.type || 'string')));

    // reset
    function resetAndReload() {
      pages = [];
      cursors = [null];
      currentPageIndex = 0;
      loadPage(0);
    }

    // pagination
    rowsPerPageSelect.addEventListener('change', () => {
      rowsPerPage = Number(rowsPerPageSelect.value) || 50;
      resetAndReload();
    });

    prevBtn.addEventListener('click', () => currentPageIndex > 0 && loadPage(currentPageIndex - 1));
    nextBtn.addEventListener('click', () => {
      const page = pages[currentPageIndex];
      if (page && page.nextCursor) loadPage(currentPageIndex + 1);
    });

    // initial
    (async () => {
      rowsPerPage = Number(rowsPerPageSelect.value) || 50;
      try {
        await loadPage(0);
      } catch (e) {
        console.error(e);
        stopLoading();
        tbody.innerHTML = '<tr><td colspan="15">Failed to load inventory. Check server logs.</td></tr>';
      }
    })();
  </script>
</body>
</html>
